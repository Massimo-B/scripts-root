#!/usr/bin/env bash

this_basename="${0##*/}"

usage() {
    cat <<EOF
This is $this_basename

Usage: $this_basename [OPTIONS] <target snapshot> <sibling snapshots>

Description:
Defragmentation of a <target snapshot> (btrfs RO snapshot) without modification or breaking parent relations, applying defragmentation to all <sibling snapshots>

Example:
$this_basename /mnt/data/snapshots/mdesk/home/home.20250725T072510+0200/ /mnt/data/snapshots/mdesk/home/home.*

Options:
    -h, --help      Show this help
    -d, --debug     Debugging mode
    
EOF
}

cleanup() {
    rm -frv "${defragdir_tmp}" || {
        echo "Failed to remove ${defragdir_tmp}"
        exit 1
    }
}

### Requirement checks:
if (( ${BASH_VERSINFO[0]} < 4 )); then
    echo "This script needs at least bash version 4"
    exit 1
fi

type -p btrfs-extent-same >/dev/null || {
    echo "btrfs-extent-same not found, install package duperemove"
    exit 1
}
type -p btrfs >/dev/null || {
    echo "btrfs not found, install package btrfs-progs"
    exit 1
}
type -p mktemp >/dev/null || {
    echo "mktemp not found, from package coreutils"
    exit 1
}

### Parsing ARGS:
while [[ $1 == -* ]]; do
    case "$1" in
        -v|--verbose)   opt_verbose=1;              shift;;
        -h|--help)      usage;                      exit 0;;
        -*) echo "invalid option: $1" 1>&2; usage;  exit 1;;
    esac
done

target_snapshot="${1}";shift
sibling_snapshots=("${@}")

defragdir_tmp="$(mktemp -d -p "$(dirname "${target_snapshot}")" "${this_basename}.XXXXXX")" || {
    echo "Failed to create temporary directory"
    exit 1
}

trap cleanup EXIT

### Verbose header:
[[ -n "$opt_verbose" ]] && printf 'Target snapshot: \t%s\n' "${target_snapshot}"
[[ -n "$opt_verbose" ]] && printf 'Sibling snapshots: \t%s\n' "${sibling_snapshots[@]}"
[[ -n "$opt_verbose" ]] && printf 'Temporary defrag directory: \t%s\n' "${defragdir_tmp}"

### Checks:
btrfs subvolume show "${target_snapshot}" | grep -qE "Flags:\s+readonly" > /dev/null || {
    echo "${target_snapshot} is not a RO snapshot"
    exit 1
}

new_sibling_snapshots=()

for sibling_snapshot in "${sibling_snapshots[@]}"; do
    # Remove target snapshot from siblings list:
    if [[ "${sibling_snapshot}" != "${target_snapshot}" || -n "$found" ]]; then
        new_sibling_snapshots+=("${sibling_snapshot}")
    else
        found=1
    fi
    btrfs subvolume show "${sibling_snapshot}" | grep -qE "Flags:\s+readonly" > /dev/null || {
        echo "${sibling_snapshot} is not a RO snapshot"
        exit 1
    }
done
sibling_snapshots=("${new_sibling_snapshots}")

if [[ ! -w "${defragdir_tmp}" ]]; then
    echo "${defragdir_tmp} is not writeable"
    exit 1
fi

### Temporary file:
defragfile="${defragdir_tmp}/defragged"

if [[ -d "${target_snapshot}" ]]; then
    cd "${target_snapshot}"
else
    echo "Directory ${target_snapshot} does not exist"
    exit 1
fi

### Main loop:
while IFS= read -r target_file; do
    [[ -n "$opt_verbose" ]] && echo "##################### ${target_file}"
    if [[ -r "${target_file}" ]]; then
        cp -f --reflink=always "${target_file}" "${defragfile}" || {
            echo "Copy ${target_file} failed"
            exit 1
        }
        btrfs fi defrag -t 512M "${defragfile}" || {
            echo "Defragmentation of ${target_file} failed"
            exit 1
        }
        size="$(stat -c %s "${defragfile}")"
        [[ -n "$opt_verbose" ]] && echo "Size: ${size}"
        for sibling_snapshot in "${sibling_snapshots[@]}"; do
            sibling_file="${sibling_snapshot}/${target_file}"
            [[ -n "$opt_verbose" ]] && echo "Sibling file: ${sibling_file}"
            if [[ -r "${sibling_file}" ]]; then
                btrfs-extent-same "$size" "${defragfile}" 0 "${sibling_file}" || {
                    echo "btrfs-extent-same on ${sibling_file} failed"
                }
            else
                [[ -n "$opt_verbose" ]] && echo "No sibling file found for snapshot ${sibling_snapshot}"
            fi
        done
    else
        [[ -n "$opt_verbose" ]] && echo "File is not readable: ${target_file}"
    fi
done < <(find . -type f -print0)

